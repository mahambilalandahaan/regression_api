# -*- coding: utf-8 -*-
"""regression_api.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1M5i8ii2ZnoX80nLY4z7cyL6DFsG_B-1Y
"""

from fastapi import FastAPI, HTTPException , Request
from pydantic import BaseModel
import joblib
import json
import numpy as np
from fastapi.middleware.cors import CORSMiddleware
from fastapi.staticfiles import StaticFiles
from fastapi.templating import Jinja2Templates

# ================================
# Load models at startup
# ================================
models = {
    "linear": joblib.load("models/linear.pkl"),
    "ridge": joblib.load("models/ridge.pkl"),
    "lasso": joblib.load("models/lasso.pkl"),
    "elasticnet": joblib.load("models/elasticnet.pkl")
}

# Load feature names
with open("models/feature_names.json", "r") as f:
    feature_names = json.load(f)

# ================================
# FastAPI App
# ================================
app = FastAPI(title="Diabetes Regression API (4 Models)")
 #Serve static files
app.mount("/static", StaticFiles(directory="static"), name="static")

# Set up templates
templates = Jinja2Templates(directory="templates")

# Root endpoint renders index.html template
@app.get("/")
def read_root(request: Request):
    return templates.TemplateResponse("index.html", {"request": request})
# ---- CORS ----
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)
# ================================
# Request Schema
# ================================
class PredictRequest(BaseModel):
    model: str
    features: dict

# ================================
# Prediction Endpoint
# ================================
@app.post("/predict")
def predict(request: PredictRequest):
    try:
        model_name = request.model.lower()
        if model_name not in models:
            raise HTTPException(
                status_code=400,
                detail=f"Invalid model name. Choose from: {list(models.keys())}"
            )

        missing = [f for f in feature_names if f not in request.features]
        if missing:
            raise HTTPException(
                status_code=400,
                detail=f"Missing features: {missing}"
            )

        input_values = np.array([request.features[f] for f in feature_names]).reshape(1, -1)
        model = models[model_name]
        prediction = model.predict(input_values)
        prediction_value = float(prediction[0])

        # Get actual regressor from pipeline if needed
        if hasattr(model, 'named_steps'):
            final_model = list(model.named_steps.values())[-1]
        else:
            final_model = model

        return {
            "model": model_name,
            "prediction": prediction_value,
            "coefficients": final_model.coef_.tolist(),
            "intercept": float(final_model.intercept_)
        }

    except Exception as e:
        print("ERROR:", e)
        raise HTTPException(status_code=500, detail=str(e))





@app.get("/result")
def show_result(request: Request, model: str, prediction: float):
    return templates.TemplateResponse(
        "result.html",
        {"request": request, "model": model, "prediction": prediction}
    )

# ================================
# Health Check
# ================================
@app.get("/health")
def health_check():
    return {"message": "Regression API is running"}